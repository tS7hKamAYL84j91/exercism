// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

function decimal_to_digits(base, decimal) {
  var _decimal = decimal;
  var _digits = /* [] */0;
  while(true) {
    var digits = _digits;
    var decimal$1 = _decimal;
    var quotient = Caml_int32.div(decimal$1, base);
    if (quotient !== 0) {
      _digits = /* :: */[
        Caml_int32.mod_(decimal$1, base),
        digits
      ];
      _decimal = quotient;
      continue ;
    } else {
      return /* :: */[
              Caml_int32.mod_(decimal$1, base),
              digits
            ];
    }
  };
}

function digits_to_decimal(base, digits) {
  return List.fold_left((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, List.mapi((function (i, x) {
                    return Caml_int32.imul(x, Math.pow(base, i));
                  }), List.rev(digits)));
}

function rebase(from, digits, target) {
  var invalid_base = function (from, target) {
    if (from <= 1) {
      return true;
    } else {
      return target <= 1;
    }
  };
  var invalid_digits = function (from, digits) {
    if (List.filter((function (i) {
                return i >= from ? true : i < 0;
              }))(digits) !== /* [] */0) {
      return true;
    } else {
      return Caml_obj.caml_equal(List.filter((function (i) {
                          return i === 0;
                        }))(digits), digits);
    }
  };
  if (digits && !(invalid_base(from, target) || invalid_digits(from, digits))) {
    return decimal_to_digits(target, digits_to_decimal(from, digits));
  }
  
}

exports.rebase = rebase;
/* No side effect */
